% Testing John's equation, helix parametrization

clear all;

%Generate object



% Extract some scanner parameters 
nv = cbct.nv/2;
na = cbct.na;
nb = cbct.nb;
SO = cbct.SO;
scale = cbct.para.scale;
cos_phi = cbct.para.cos_phi;
sin_phi = cbct.para.sin_phi;
sd_z = scale*cbct.para.sd_z;

% Compute detector positions
OD = cbct.OD;
y_det = scale*(cbct.para.y_det);
z_det = scale*(cbct.para.z_det);

% Verify that f is correct
h = cbct.vtab/(2*pi*cbct.rps); 



g1 = f.dataArrayNorm(:,:,:,1);
g2 = f.dataArrayNorm(:,:,:,2);
framelet = Transforms.FrameletSystem(3,'linear',1);

disp('Computing framelet expansion of u')
alpha1 = framelet.forwardTransform(g1);
alpha2 = framelet.forwardTransform(g2);

g1 = alpha1.frameletArray{1}{1,1};
g2 = alpha2.frameletArray{1}{1,1};

% Compute approximate John's equation 
disp('approximating Johns Equation')
R = SO+OD;
%dzeta = 0.03125;  % NOTE: THIS IS SPECIFIC TO CURRENT SCAN SETTINGS, NOTABLY THE PI/4 PHASE SHIFT
dzeta = (cbct.para.sd_z(2)-cbct.para.sd_z(1))*cbct.para.scale;
dphi = 2*pi*cbct.rps/cbct.fps;
da = scale*cbct.para.dy_det;
db = scale*cbct.para.dz_det;


% gtb
gtb = (g1(:,3:end,3:end)+g1(:,1:end-2,1:end-2)-g1(:,1:end-2,3:end)-g1(:,3:end,1:end-2))/(4*db*dphi);
% gaz
gaz = (g2(3:end,:,:)+g1(1:end-2,:,:)-g2(1:end-2,:,:)-g1(3:end,:,:))/(4*da*dzeta);
% gbz
gbz = (g2(:,3:end,:)+g1(:,1:end-2,:)-g2(:,1:end-2,:)-g1(:,3:end,:))/(4*db*dzeta);
% gb
gb = (g1(:,3:end,:)-g1(:,1:end-2,:))/(2*db);
% gaa
gaa = (g1(3:end,:,:)+g1(1:end-2,:,:)-2*g1(2:end-1,:,:))/(da*da);
% gab
gab = (g1(3:end,3:end,:)+g1(1:end-2,1:end-2,:)-g1(3:end,1:end-2,:)-g1(1:end-2,3:end,:))/(4*da*db);
% a
[a,b,NULL] = ndgrid(y_det,z_det,zeros(nv,1));
% b 


D = R*gtb(2:end-1,:,:) - R*SO*gaz(:,2:end-1,2:end-1) -...
    R*h*gbz(2:end-1,:,2:end-1) +...
    2.*a(2:end-1,2:end-1,2:end-1).*gb(2:end-1,:,2:end-1) +...
    a(2:end-1,2:end-1,2:end-1).*b(2:end-1,2:end-1,2:end-1).*gaa(:,2:end-1,2:end-1) +...
    (a(2:end-1,2:end-1,2:end-1).^2+R^2).*gab(:,:,2:end-1);







